<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>LIGHTRI — Le Trieur (sobre)</title>
<style>
  :root{
    --bg:#0b1116;
    --panel:#0f1720;
    --muted:#9fb0c8;
    --accent:#caa45f;
    --card:#111720;
    --glass: rgba(255,255,255,0.02);
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:#e7f1fb;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial; -webkit-font-smoothing:antialiased}
  .wrap{max-width:1100px;margin:28px auto;padding:20px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.03)}
  header{display:flex;align-items:center;gap:14px;margin-bottom:14px}
  .logo{width:64px;height:64px;border-radius:10px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));display:flex;align-items:center;justify-content:center;color:var(--accent);font-weight:700;font-size:20px}
  h1{margin:0;font-size:20px}
  .subtitle{margin:4px 0 0;color:var(--muted);font-size:13px}

  .controls{display:flex;gap:12px;flex-wrap:wrap;align-items:center;margin:14px 0}
  input[type=file]{padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:var(--glass);color:var(--muted)}
  button{padding:10px 14px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--accent);cursor:pointer;font-weight:600}
  button.ghost{color:var(--muted);border:1px dashed rgba(255,255,255,0.03)}
  .small{font-size:13px;color:var(--muted)}

  main{display:flex;gap:18px}
  .left{flex:1;display:flex;flex-direction:column}
  .right{width:360px;min-width:280px}

  textarea#pasteArea{min-height:180px;border-radius:10px;padding:12px;background:var(--card);border:1px solid rgba(255,255,255,0.03);color:#eaf3ff;resize:vertical;font-family:monospace}
  textarea#output{min-height:420px;border-radius:10px;padding:12px;background:linear-gradient(180deg,#07101a,#0b1720);border:1px solid rgba(255,255,255,0.03);color:#eaf3ff;resize:vertical;font-family:monospace}
  pre#log{min-height:120px;border-radius:8px;padding:10px;background:#071021;color:#9fcaf0;overflow:auto;font-family:monospace}

  .opts{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .opts label{display:flex;align-items:center;gap:8px;color:var(--muted);font-size:13px}
  input[type=number]{width:72px;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:var(--card);color:#eaf3ff}

  .progress{height:8px;background:rgba(255,255,255,0.03);border-radius:8px;margin-top:10px;overflow:hidden}
  .progress > i{display:block;height:100%;background:linear-gradient(90deg,var(--accent),#ffd7a8);width:0%}

  .note{margin-top:8px;color:var(--muted);font-size:13px}
  .footer{display:flex;justify-content:space-between;margin-top:14px;color:var(--muted);font-size:13px}

  @media (max-width:900px){
    main{flex-direction:column}
    .right{width:100%}
  }
</style>
</head>
<body>
  <div class="wrap" role="application" aria-label="LIGHTRI trieur">
    <header>
      <div class="logo" aria-hidden="true">L</div>
      <div>
        <h1>LIGHTRI — Le Trieur</h1>
        <div class="subtitle">Colle ton texte, ou charge des .txt — supprime/masque, lookup BIN via ton endpoint Netlify</div>
      </div>
    </header>

    <div class="controls" role="region" aria-label="Contrôles">
      <input id="fileInput" type="file" accept=".txt" multiple aria-label="choisir fichiers txt">
      <button id="processFiles">Traiter fichiers</button>
      <button id="processPaste" class="ghost">Traiter texte collé</button>
      <button id="download">Télécharger résultat</button>
      <div class="small" style="margin-left:auto">Records traités : <span id="count">0</span></div>
    </div>

    <main>
      <div class="left">
        <div style="display:flex;gap:12px;align-items:center;margin-bottom:10px">
          <div style="flex:1">
            <label class="small">Zone de texte (colle ton texte ici — tu n'as pas besoin d'un .txt)</label>
            <textarea id="pasteArea" placeholder="Colle ton texte ici..."></textarea>
          </div>
          <div style="width:180px">
            <div class="opts" style="flex-direction:column;align-items:flex-start">
              <label><input id="remove8" type="checkbox"> Supprimer 8 premiers chiffres</label>
              <label style="margin-top:6px">Masquer derniers <input id="maskN" type="number" value="10" min="0"> chiffres</label>
              <label style="margin-top:6px"><input id="usePublicProxy" type="checkbox"> Autoriser proxies publics</label>
            </div>
          </div>
        </div>

        <div class="note">Le parseur récupère automatiquement les lignes qui contiennent un caractère <code>|</code> ou qui commencent par un numéro de carte. Les petites lignes numériques isolées sont ignorées.</div>

        <textarea id="output" placeholder="Résultat formaté..." readonly></textarea>

        <div class="progress" aria-hidden="true"><i id="bar"></i></div>
      </div>

      <aside class="right">
        <div style="margin-bottom:12px">
          <div class="small">Logs / Débogage</div>
          <pre id="log" aria-live="polite"></pre>
        </div>

        <div style="margin-top:10px" class="note">API Netlify utilisée automatiquement pour BIN lookup.</div>
      </aside>
    </main>

    <div class="footer">
      <div class="small">LIGHTRI — sobre • stable</div>
      <div class="small">Built for you</div>
    </div>
  </div>

<script>
/*
  LIGHTRI final v3
  - uses your Netlify endpoint for BIN lookups
  - robust parsing of pasted text or files
  - processes all records sequentially
  - options to remove first 8 digits and mask last N digits
*/

// ========== CONFIG ===========
const NETLIFY_BASE = "https://celebrated-strudel-1c13f6.netlify.app/.netlify/functions/binlookup?bin="; 
// public proxies (only if user allows)
const PUBLIC_PROXIES = ["https://corsproxy.io/?", "https://api.allorigins.win/raw?url="];
// ==============================

const fileInput = document.getElementById('fileInput');
const processFilesBtn = document.getElementById('processFiles');
const processPasteBtn = document.getElementById('processPaste');
const downloadBtn = document.getElementById('download');
const pasteArea = document.getElementById('pasteArea');
const output = document.getElementById('output');
const logEl = document.getElementById('log');
const remove8Box = document.getElementById('remove8');
const maskNInput = document.getElementById('maskN');
const usePublicProxyBox = document.getElementById('usePublicProxy');
const countEl = document.getElementById('count');
const bar = document.getElementById('bar');

function lg(...args){
  logEl.textContent += args.join(' ') + '\\n';
  logEl.scrollTop = logEl.scrollHeight;
}
function clearLog(){ logEl.textContent = ''; }

function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

function group4(s){
  return s.replace(/(\\d{4})(?=\\d)/g,'$1 ');
}
function maskLast(s, n){
  const digits = s.replace(/\\D/g,'');
  if(n<=0) return group4(digits);
  if(digits.length <= n) return '*'.repeat(digits.length);
  const keep = digits.slice(0, digits.length - n);
  const masked = '*'.repeat(n);
  return group4(keep) + ' ' + masked;
}

// parse records robustly:
// strategy:
// 1) try regex to find segments starting with a long digit sequence (card) followed by rest of line containing '|'
// 2) fallback: take any line containing '|' as record
function extractRecordsFromText(text){
  const records = [];
  if(!text) return records;
  // normalize tabs -> spaces
  const norm = text.replace(/\\t/g,' ');
  // regex: card-like number (12-19 digits) followed by anything until end of line that contains a '|' 
  const re = /\\d{12,19}[\\s\\S]*?\\|[^\\n\\r]*/g;
  let m;
  while((m = re.exec(norm)) !== null){
    const rec = m[0].trim();
    // sometimes regex captures only part; ensure it contains '|'
    if(rec.includes('|')) records.push(rec);
  }
  if(records.length>0) return records;

  // fallback: split by lines and take lines with '|'
  const lines = norm.split(/\\r?\\n/);
  for(const raw of lines){
    const line = raw.trim();
    if(!line) continue;
    if(line.includes('|')){
      records.push(line);
    } else {
      // if line has a long digit string and rest on same line, try to recover (rare)
      const m2 = line.match(/\\d{12,19}/);
      if(m2 && line.includes(' ')){
        // try to take substring from the card number onward
        const idx = line.indexOf(m2[0]);
        const sub = line.slice(idx);
        if(sub.includes('|')) records.push(sub.trim());
      } else {
        // ignore short numeric lines (IDs)
      }
    }
  }
  return records;
}

// BIN lookup: try NETLIFY endpoint, then public proxies if allowed
async function binLookup(bin){
  bin = String(bin).slice(0,6);
  if(!/^[0-9]{6}$/.test(bin)) return null;
  // 1) try Netlify endpoint (your own)
  try{
    lg('BIN lookup via Netlify for', bin);
    const r = await fetch(NETLIFY_BASE + encodeURIComponent(bin), { method:'GET' });
    if(r.ok){
      const j = await r.json();
      return j;
    } else {
      lg('Netlify returned', r.status);
    }
  } catch(e){
    lg('Netlify fetch error:', e && e.message ? e.message : e);
  }

  // 2) try public proxies if user allows
  if(usePublicProxyBox.checked){
    for(const p of PUBLIC_PROXIES){
      try{
        const url = p + encodeURIComponent('https://lookup.binlist.net/' + bin);
        lg('Trying public proxy', p);
        const r = await fetch(url, { method:'GET' });
        if(r.ok){
          const j = await r.json();
          return j;
        } else {
          lg('Public proxy returned', r.status);
        }
      } catch(e){
        lg('Public proxy error', e && e.message ? e.message : e);
      }
      await sleep(200);
    }
  }
  lg('BIN lookup failed for', bin);
  return null;
}

// process single record string (one line)
async function processRecord(rec, options){
  // rec expected to contain '|' separating fields
  const parts = rec.split('|').map(p => p.trim());
  // pad up to 12 fields
  while(parts.length < 12) parts.push('');
  const Carte = {
    CardNumber: parts[0] || '',
    ExpMonth: parts[1] || '',
    ExpYear: parts[2] || '',
    CVV: parts[3] || '',
    Country: parts[4] || '',
    FullName: parts[5] || '',
    Address: parts[6] || '',
    City: parts[7] || '',
    City2: parts[8] || '',
    Zip: parts[9] || '',
    Phone: parts[10] || '',
    Email: parts[11] || ''
  };

  // clean digits
  let digits = (Carte.CardNumber || '').replace(/\\D/g,'');
  if(!digits || digits.length < 6) {
    lg('Skipped: card invalid or <6 digits:', Carte.CardNumber);
    return null;
  }

  // remove first 8 digits if required
  if(options.remove8){
    if(digits.length > 8) digits = digits.slice(8);
    else { lg('Skipped: after removing 8 digits number too short'); return null; }
  }
  if(digits.length < 6){ lg('Skipped: less than 6 digits after remove8'); return null; }

  const BIN = digits.slice(0,6);

  // call BIN lookup
  const binInfo = await binLookup(BIN);

  // display number (mask or grouped)
  const display = (options.maskN && options.maskN > 0) ? maskLast(digits, options.maskN) : group4(digits);

  // assemble result block
  const scheme = (binInfo && binInfo.scheme) ? binInfo.scheme : 'Non spécifié';
  const type = (binInfo && binInfo.type) ? binInfo.type : 'Non spécifié';
  const brand = (binInfo && binInfo.brand) ? binInfo.brand : 'Non spécifié';
  const bankName = (binInfo && binInfo.bank && binInfo.bank.name) ? binInfo.bank.name : 'Non spécifié';
  const countryName = (binInfo && binInfo.country && binInfo.country.name) ? binInfo.country.name : 'Non spécifié';

  const block = [
`💳 +1 CARD`,
`└ ${display}`,
``,
`🏦 Informations Personnelles`,
`├ 🕵️ Nom complet : ${Carte.FullName || ''}`,
`├ 🏠 Adresse : ${Carte.Address || ''}`,
`├ 📮 Zip : ${Carte.Zip || ''}`,
`├ 🏢 Ville : ${Carte.City || ''}`,
`├ 📞 Numéro de téléphone : ${Carte.Phone || ''}`,
`└ 📧 Email : ${Carte.Email || ''}`,
``,
`🏦 Carte de Paiement`,
`├ 🍒 Titulaire : ${Carte.FullName || ''}`,
`├ 💳 Numéro de carte : ${display}`,
`├ 💳 Bin : ${BIN}`,
`├ 💳 Réseau : ${scheme}`,
`├ 💳 Banque : ${bankName} (${countryName})`,
`├ 💳 Niveau : ${brand}`,
`├ 💳 Type : ${type}`,
`├ 📅 Expiration : ${Carte.ExpMonth || ''}/${Carte.ExpYear || ''}`,
`└ 🔒 Cryptogramme visuel : ${Carte.CVV || ''}`,
``
  ].join('\\n');

  return { block, binInfo };
}

// process many records sequentially
async function processRecords(records, options){
  const results = [];
  clearLog();
  lg('Total records found:', records.length);
  countEl.textContent = '0';
  bar.style.width = '0%';

  for(let i=0;i<records.length;i++){
    const rec = records[i];
    lg('Processing', i+1, '/', records.length);
    const r = await processRecord(rec, options);
    if(r && r.block){
      results.push(r.block);
    }
    // update progress
    const pct = Math.round(((i+1)/records.length)*100);
    bar.style.width = pct + '%';
    countEl.textContent = String(results.length);
    // small delay
    await sleep(120);
  }

  bar.style.width = '100%';
  lg('Finished processing. Records output:', results.length);
  return results.join('\\n');
}

// extract records from pasted text or file concatenation
function getRecordsFromText(text){
  return extractRecordsFromText(text);
}

// ===== UI bindings =====
processPasteBtn.addEventListener('click', async () => {
  const text = pasteArea.value || '';
  if(!text.trim()){ alert('Colle ton texte dans la zone prévue.'); return; }
  const records = getRecordsFromText(text);
  if(records.length === 0){ alert('Aucun enregistrement valide trouvé (attend des lignes contenant "|").'); return; }
  const out = await processRecords(records, { remove8: remove8Box.checked, maskN: parseInt(maskNInput.value||'0',10) });
  output.value = out;
});

processFilesBtn.addEventListener('click', async () => {
  const files = Array.from(fileInput.files || []);
  if(files.length === 0){ alert('Choisis un ou plusieurs fichiers .txt'); return; }
  let combined = '';
  for(const f of files){
    try{ lg('Reading file', f.name); const t = await f.text(); combined += '\\n' + t; } catch(e){ lg('Failed read', f.name, e && e.message ? e.message : e); }
  }
  const records = getRecordsFromText(combined);
  if(records.length === 0){ alert('Aucun enregistrement valide trouvé dans les fichiers.'); return; }
  const out = await processRecords(records, { remove8: remove8Box.checked, maskN: parseInt(maskNInput.value||'0',10) });
  output.value = out;
});

downloadBtn.addEventListener('click', () => {
  if(!output.value){ alert('Aucun résultat à télécharger'); return; }
  const filename = `LIGHTRI_Result_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.txt`;
  const blob = new Blob([output.value], {type:'text/plain;charset=utf-8'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
});

</script>
</body>
</html>